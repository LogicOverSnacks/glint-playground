import{$f as Ve,$g as q,A as me,D as k,Di as rt,Eg as Ie,F as ye,G as Ee,Gc as Me,Ig as x,Ih as ot,K as Re,L as Q,Mh as ee,N as ge,Ng as U,Og as g,Pd as Fe,Qd as De,Rc as Oe,S as b,Sg as B,T as P,Td as He,Th as st,U as v,Ug as Ke,Uh as H,W as Te,Yg as Ye,Zg as Je,_ as J,_g as Z,a as i,b as p,ba as I,be as Ne,bh as $e,cd as fe,ch as Ge,ee as ze,fe as Qe,gd as ke,gg as _e,gh as Xe,hg as Se,i as he,ig as $,kg as u,lg as G,m as L,n as a,nd as xe,ng as V,od as je,og as h,pd as Le,q as F,r as E,rg as X,s as w,sc as Ue,sh as Ze,th as qe,uh as et,v as ue,vg as We,wh as tt,x as ve,y as Be,zg as D}from"./chunk-RKMHOEIU.js";var Ce=(()=>{class s{static{this.type="[Repositories] AddRepository"}constructor(t,e={}){this.repositoryPath=t,this.settings=e}}return s})(),it=(()=>{class s{static{this.type="[Repositories] DeleteRepository"}constructor(t){this.repositoryPath=t}}return s})(),nt=(()=>{class s{static{this.type="[Repositories] OpenRepository"}constructor(t){this.repositoryPath=t}}return s})(),Pe=(()=>{class s{static{this.type="[Repositories] CloseRepository"}constructor(t){this.repositoryPath=t}}return s})(),pt=(()=>{class s{static{this.type="[Repositories] UpdateRepositoryBookmarks"}constructor(t){this.bookmarks=t}}return s})(),lt=(()=>{class s{static{this.type="[Repositories] ChangeSelectedRemote"}constructor(t,e){this.repositoryPath=t,this.remote=e}}return s})(),at=(()=>{class s{static{this.type="[Repositories] AddOrUpdateProfileCredential"}constructor(t,e,o){this.repositoryPath=t,this.profileId=e,this.credentials=o}}return s})(),ct=(()=>{class s{static{this.type="[Repositories] ReorderOpenRepositories"}constructor(t){this.repositoryPaths=t}}return s})(),N=(()=>{class s{static{this.type="[Repositories] ChangeSelectedRepository"}constructor(t){this.repositoryPath=t}}return s})(),te=(()=>{class s{static{this.type="[Repositories] ChangeSelectedCommit"}constructor(t,e){this.repositoryPath=t,this.commitId=e}}return s})(),dt=(()=>{class s{static{this.type="[Repositories] ChangeSelectedFile"}constructor(t,e){this.repositoryPath=t,this.selected=e}}return s})(),oe=(()=>{class s{static{this.type="[Repositories] ChangeSelectedMerge"}constructor(t,e){this.repositoryPath=t,this.mergeId=e}}return s})(),S=function(s){return s[s.commits=0]="commits",s[s.currentBranch=1]="currentBranch",s[s.currentBranchCommitId=2]="currentBranchCommitId",s[s.currentBranchUpstreamBranch=3]="currentBranchUpstreamBranch",s[s.headCommitId=4]="headCommitId",s[s.mergeHeads=5]="mergeHeads",s[s.merges=6]="merges",s[s.name=7]="name",s[s.references=8]="references",s[s.remotes=9]="remotes",s[s.stagedChanges=10]="stagedChanges",s[s.stashes=11]="stashes",s[s.submodules=12]="submodules",s[s.unstagedChanges=13]="unstagedChanges",s}(S||{}),z=(()=>{class s{static{this.type="[Repositories] RefreshRepository"}constructor(t,e=null){this.repositoryPath=t,this.scopes=e}}return s})(),Ae=(()=>{class s{static{this.type="[Repositories] LoadRepositoryCommits"}constructor(t,e,o){this.repositoryPath=t,this.toCommitId=e,this.cancel=o}}return s})(),se=(()=>{class s{static{this.type="[Repositories] ScrollRepository"}constructor(t,e){this.repositoryPath=t,this.scrollIndex=e}}return s})(),re=(()=>{class s{static{this.type="[Repositories] ScrollRepositoryToCommit"}constructor(t,e){this.repositoryPath=t,this.commitId=e}}return s})();var ht=(()=>{class s{static{this.type="[Repositories] UpdateCommitMessage"}constructor(t,e){this.repositoryPath=t,this.message=e}}return s})(),ie=(()=>{class s{static{this.type="[Repositories] ChangeVisibleReferences"}constructor(t,e){this.repositoryPath=t,this.referenceNames=e}}return s})(),ut=(()=>{class s{static{this.type="[Repositories] ChangeBranchesExpanded"}constructor(t,e,o){this.repositoryPath=t,this.branchNames=e,this.expanded=o}}return s})(),mt=(()=>{class s{static{this.type="[Repositories] ResetState"}}return s})();var ne=(()=>{class s{static{this.type="[RepositoriesTransient] InitializeTransient"}constructor(t,e){this.repositoryIds=t,this.selectedRepositoryId=e}}return s})(),_=(()=>{class s{static{this.type="[RepositoriesTransient] OpenTransientRepository"}constructor(t){this.repositoryPath=t}}return s})(),pe=(()=>{class s{static{this.type="[RepositoriesTransient] CloseTransientRepository"}constructor(t){this.repositoryPath=t}}return s})(),we=(()=>{class s{static{this.type="[RepositoriesTransient] WorkingDirectoryChanged"}constructor(t){this.repositoryPath=t}}return s})(),yt=(()=>{class s{static{this.type="[RepositoriesTransient] LoadCommitEdit"}constructor(t,e){this.repositoryPath=t,this.rootCommitId=e}}return s})(),Rt=(()=>{class s{static{this.type="[RepositoriesTransient] PerformRepositoryAction"}constructor(t,e){this.repositoryPath=t,this.action=e}}return s})(),gt=(()=>{class s{static{this.type="[RepositoriesTransient] UndoLastAction"}constructor(t){this.repositoryPath=t}}return s})(),ft=(()=>{class s{static{this.type="[RepositoriesTransient] RedoLastAction"}constructor(t){this.repositoryPath=t}}return s})(),St=(()=>{class s{static{this.type="[RepositoriesTransient] ResetState"}}return s})();var le=new Ve("repositories"),Mt=s=>p(i({},s),{repositorySettings:U(s.repositorySettings,(R,t)=>p(i({},t),{profiles:Array.from(t.profiles.entries()),expandedBranches:[...t.expandedBranches]}))}),Ot=s=>p(i({},s),{repositorySettings:U(s.repositorySettings,(R,t)=>p(i({},t),{profiles:new Map(t.profiles),expandedBranches:new Set(t.expandedBranches)}))});var M,It={isInitialized:!1,openRepositories:{},loadingRepositories:{}},y=(()=>{let s=class ae{static{M=this}static{this.maxUndoActions=10}static isInitialized(t){return t.isInitialized}static openRepositories(t){return t.openRepositories}static loadingRepositories(t){return t.loadingRepositories}static repositorySettings(t){return t.repositorySettings}static mostRecentAction(t){return V([M],e=>e.openRepositories[t]?.recentActions[0]??null)}static mostRecentActionState(t){return V([M],e=>e.openRepositories[t]?.mostRecentActionState??null)}initializeTransient(t,e){return t.dispatch(new N(null)).pipe(v(()=>{t.setState(o=>p(i({},o),{isInitialized:!0}))}),b(()=>ue(e.repositoryIds.map(o=>o===e.selectedRepositoryId?t.dispatch(new _(o)).pipe(P(ve(3e3)),b(()=>t.dispatch(new N(o))),v(()=>this.router.navigate(["/standard/default"]))):t.dispatch(new _(o))))))}openTransientRepository(t,e){if(!(t.getState().openRepositories[e.repositoryPath]||t.getState().loadingRepositories[e.repositoryPath]))return this.repositoriesApi.getRepositoryName(e.repositoryPath).pipe(v(o=>{t.setState(r=>p(i({},r),{loadingRepositories:p(i({},r.loadingRepositories),{[e.repositoryPath]:{loaded:!1,name:o}})}))}),b(()=>this.repositoriesApi.openRepository(e.repositoryPath)),b(()=>{let o=this.refreshQueue[e.repositoryPath]??new Map;this.refreshQueue[e.repositoryPath]||(this.refreshQueue[e.repositoryPath]=o);let r=Object.values(S).filter(l=>typeof l=="number"),n=[];for(let l of r){let c=new he;o.set(l,c),n.push([l,c])}return this.refreshScopes(t,e.repositoryPath,n)}),v(o=>{if(this.watcherSubscriptions[e.repositoryPath])throw new ke(e.repositoryPath);this.watcherSubscriptions[e.repositoryPath]=this.repositoriesApi.onWorkingDirectoryChanges(e.repositoryPath).subscribe(()=>t.dispatch(new we(e.repositoryPath))),t.setState(n=>p(i({},n),{openRepositories:p(i({},n.openRepositories),{[e.repositoryPath]:p(i(i({name:"<Unknown>",remotes:[],commits:[],merges:[],allCommitsLoaded:!1,headCommitId:null,stagedChanges:[],unstagedChanges:[],selectedFile:null,references:[],currentBranch:null,currentBranchCommitId:null,currentBranchUpstreamBranch:null,submodules:[],mergeHeads:[],stashes:[]},n.openRepositories[e.repositoryPath]),Object.fromEntries(o.flat())),{scrollIndex:0,selectedMergeId:null,loaded:!0,loadingCommitEdit:!1,recentActions:[],recentUndoneActions:[],performingAction:null,mostRecentActionState:null})})}));let r=t.getState().openRepositories[e.repositoryPath]?.remotes;r&&this.loadAvatars(r)}),k(o=>(t.setState(r=>p(i({},r),{openRepositories:D(r.openRepositories,e.repositoryPath)})),Fe.matches(o)?E(()=>new B(o)):De.matches(o)?E(()=>new B(o)):E(()=>o))),Q(()=>{t.setState(o=>p(i({},o),{loadingRepositories:D(o.loadingRepositories,e.repositoryPath)}))}))}closeTransientRepository(t,e){return t.setState(o=>{let r=this.watcherSubscriptions[e.repositoryPath];r&&(r.unsubscribe(),delete this.watcherSubscriptions[e.repositoryPath]);let n=this.refreshQueue[e.repositoryPath];if(n){for(let l of n.values())l.next(),l.complete();delete this.refreshQueue[e.repositoryPath]}return p(i({},o),{openRepositories:D(o.openRepositories,e.repositoryPath),loadingRepositories:D(o.loadingRepositories,e.repositoryPath)})}),this.repositoriesApi.closeRepository(e.repositoryPath)}changeSelectedCommit(t,e){t.setState(o=>p(i({},o),{openRepositories:g(o.openRepositories,e.repositoryPath,r=>p(i({},r),{selectedFile:null,selectedMergeId:e.commitId?null:r.selectedMergeId}))}))}changeSelectedMerge(t,e){let o=t.getState().openRepositories[e.repositoryPath]?.selectedMergeId;o?.fromId===e.mergeId?.fromId&&o?.toId===e.mergeId?.toId||t.setState(r=>p(i({},r),{openRepositories:g(r.openRepositories,e.repositoryPath,n=>p(i({},n),{selectedFile:null,selectedMergeId:e.mergeId}))}))}changeSelectedFile(t,e){t.setState(o=>p(i({},o),{openRepositories:g(o.openRepositories,e.repositoryPath,r=>p(i({},r),{selectedFile:e.selected}))}))}workingDirectoryChanged(t,e){return t.dispatch(new z(e.repositoryPath,[S.mergeHeads,S.unstagedChanges,S.submodules]))}refreshRepository(t,e){if(!t.getState().openRepositories[e.repositoryPath])throw new B(new fe(e.repositoryPath));let o=this.refreshQueue[e.repositoryPath]??new Map;this.refreshQueue[e.repositoryPath]||(this.refreshQueue[e.repositoryPath]=o);let r=e.scopes??Object.values(S).filter(l=>typeof l=="number"),n=[];for(let l of r){let c=o.get(l);c?c.next():(c=new he,o.set(l,c)),n.push([l,c])}return this.refreshScopes(t,e.repositoryPath,n).pipe(v(l=>{let c=t.getState().openRepositories[e.repositoryPath];if(!c)throw new B(new fe(e.repositoryPath));t.setState(d=>p(i({},d),{openRepositories:p(i({},d.openRepositories),{[e.repositoryPath]:i(i({},c),Object.fromEntries(l.flat()))})}))}))}loadRepositoryCommits(t,e){let o=t.getState().openRepositories[e.repositoryPath],n=this.store.selectSnapshot(M.repositorySettings)[e.repositoryPath]?.visibleReferences??null;if(o&&!o.allCommitsLoaded)return e.toCommitId?o.commits.some(l=>l.id===e.toCommitId)?void 0:F([o.commits,o.commits.length,o.allCommitsLoaded]).pipe(Re(([l,c,d])=>d||l.some(C=>C.id===e.toCommitId)?L:this.historyApi.getHistory(e.repositoryPath,n,c).pipe(P(e.cancel??me),w(C=>[[...l,...C],c+x,C.length<x]))),ge(),v(([l,,c])=>{t.setState(d=>p(i({},d),{openRepositories:g(d.openRepositories,e.repositoryPath,f=>p(i({},f),{commits:c||l.length>f.commits.length?l:f.commits,allCommitsLoaded:c||f.allCommitsLoaded}))}))})):this.historyApi.getHistory(e.repositoryPath,n,o.commits.length).pipe(P(e.cancel??me),v(l=>{t.setState(c=>p(i({},c),{openRepositories:g(c.openRepositories,e.repositoryPath,d=>p(i({},d),{commits:[...d.commits,...l],allCommitsLoaded:l.length<x}))}))}))}scrollRepository(t,e){t.setState(o=>p(i({},o),{openRepositories:g(o.openRepositories,e.repositoryPath,r=>p(i({},r),{scrollIndex:e.scrollIndex}))}))}scrollRepositoryToCommit(t,e){if(e.commitId==="head"){t.setState(o=>p(i({},o),{openRepositories:g(o.openRepositories,e.repositoryPath,r=>p(i({},r),{scrollIndex:0}))}));return}if(e.commitId.startsWith("merge:")){let o=e.commitId.match(/^merge:([^:]+):([^:]+)$/);o&&t.setState(r=>p(i({},r),{openRepositories:g(r.openRepositories,e.repositoryPath,n=>{let l=n.merges.findIndex(d=>d.fromCommitId===o[1]&&d.toCommitId===o[2]),c=n.stagedChanges?.length>0||n.unstagedChanges?.length>0||n.commits.length===0;return p(i({},n),{scrollIndex:l>=0?l+(c?1:0):n.scrollIndex})})}));return}return t.dispatch(new Ae(e.repositoryPath,e.commitId,this.actions.pipe(Se(se,re)))).pipe(P(this.actions.pipe(Se(se,re))),v(()=>{t.setState(o=>p(i({},o),{openRepositories:g(o.openRepositories,e.repositoryPath,r=>{let n=r.commits.findIndex(d=>d.id===e.commitId),l=r.stagedChanges?.length>0||r.unstagedChanges?.length>0||r.commits.length===0,c=n>=0?n+(l?1:0)+r.merges.length:r.scrollIndex;return p(i({},r),{scrollIndex:c})})}))}))}loadCommitEdit(t,e){return t.setState(o=>p(i({},o),{openRepositories:g(o.openRepositories,e.repositoryPath,r=>p(i({},r),{loadingCommitEdit:!0}))})),this.commitsApi.startCommitEditing(e.repositoryPath,e.rootCommitId).pipe(k(o=>He.matches(o)?E(()=>new B(o)):Oe.matches(o)?E(()=>new B(o)):E(()=>o)),b(()=>t.dispatch(new z(e.repositoryPath))),Q(()=>{t.setState(o=>p(i({},o),{openRepositories:g(o.openRepositories,e.repositoryPath,r=>p(i({},r),{loadingCommitEdit:!1}))}))}))}performRepositoryAction(t,e){t.setState(n=>p(i({},n),{openRepositories:g(n.openRepositories,e.repositoryPath,l=>p(i({},l),{performingAction:"do"}))}));let o=!!e.action.undo,r=()=>{o=!1};return e.action.do(r).pipe(v(n=>{t.setState(l=>p(i({},l),{openRepositories:g(l.openRepositories,e.repositoryPath,c=>p(i({},c),{recentActions:o?[p(i({},e.action),{state:n}),...c.recentActions].slice(0,M.maxUndoActions):[],recentUndoneActions:[],mostRecentActionState:n}))}))}),Q(()=>{t.setState(n=>p(i({},n),{openRepositories:g(n.openRepositories,e.repositoryPath,l=>p(i({},l),{performingAction:null}))}))}))}undoLastAction(t,e){let[o,...r]=t.getState().openRepositories[e.repositoryPath]?.recentActions??[],n=o?.undo;if(!o||!n){t.setState(l=>p(i({},l),{openRepositories:g(l.openRepositories,e.repositoryPath,c=>p(i({},c),{recentActions:[],recentUndoneActions:[],performingAction:null,mostRecentActionState:null}))}));return}return t.setState(l=>p(i({},l),{openRepositories:g(l.openRepositories,e.repositoryPath,c=>p(i({},c),{recentActions:r,recentUndoneActions:[o,...c.recentUndoneActions].slice(0,M.maxUndoActions),performingAction:"undo",mostRecentActionState:r[0]?.state??null}))})),n(o.state).pipe(k(l=>{t.setState(f=>p(i({},f),{openRepositories:g(f.openRepositories,e.repositoryPath,C=>p(i({},C),{recentActions:[],recentUndoneActions:[],mostRecentActionState:null}))}));let c=this.translateService.translate(o.name),{text:d}=this.translateService.translateError(l);throw new B(new ze(c,d))}),Q(()=>{t.setState(l=>p(i({},l),{openRepositories:g(l.openRepositories,e.repositoryPath,c=>p(i({},c),{performingAction:null}))}))}))}redoLastAction(t,e){let[o,...r]=t.getState().openRepositories[e.repositoryPath]?.recentUndoneActions??[];if(!o)return;t.setState(c=>p(i({},c),{openRepositories:g(c.openRepositories,e.repositoryPath,d=>p(i({},d),{performingAction:"redo"}))}));let n=!!o.undo,l=()=>{n=!1};return o.do(l).pipe(v(c=>{t.setState(d=>p(i({},d),{openRepositories:g(d.openRepositories,e.repositoryPath,f=>p(i({},f),{recentActions:n?[p(i({},o),{state:c}),...f.recentActions].slice(0,M.maxUndoActions):[],recentUndoneActions:r,mostRecentActionState:c}))}))}),k(c=>{t.setState(C=>p(i({},C),{openRepositories:g(C.openRepositories,e.repositoryPath,A=>p(i({},A),{recentActions:[],recentUndoneActions:[],mostRecentActionState:null}))}));let d=this.translateService.translate(o.name),{text:f}=this.translateService.translateError(c);throw new B(new Qe(d,f))}),Q(()=>{t.setState(c=>p(i({},c),{openRepositories:g(c.openRepositories,e.repositoryPath,d=>p(i({},d),{performingAction:null}))}))}))}resetState(t,e){t.setState(X(It));for(let o of Object.values(this.watcherSubscriptions))o.unsubscribe();this.watcherSubscriptions={},this.refreshQueue={}}constructor(t,e,o,r,n,l,c,d,f,C,A,m,j){this.router=t,this.actions=e,this.store=o,this.avatarCacheService=r,this.commitsApi=n,this.historyApi=l,this.mergesApi=c,this.providerUrlMatcherService=d,this.remotesApi=f,this.repositoriesApi=C,this.stashApi=A,this.submodulesApi=m,this.translateService=j,this.watcherSubscriptions={},this.refreshQueue={}}loadAvatars(t){let e=t.flatMap(o=>{let r=this.providerUrlMatcherService.matchProvider(o.url);return r?.type==="bitbucket"||r?.type==="github"?r:[]});for(let o of e)this.avatarCacheService.loadFromCommits(o)}refreshScopes(t,e,o){let r=t.getState().openRepositories[e],n=r?.scrollIndex??0,l=r?.selectedFile??null,c=C=>C.oldFilePath===l?.oldFilePath&&C.newFilePath===l?.newFilePath,d=(...C)=>C,f=o.map(([C,A])=>{switch(C){case S.commits:{let m=this.store.selectSnapshot(M.repositorySettings)[e];if(!m)return F([]);let j=m.visibleReferences;return this.historyApi.getHistory(e,j,0).pipe(P(A),b(O=>F([O,x,O.length<x]).pipe(Re(([K,T,de])=>de||T>=n?L:this.historyApi.getHistory(e,j,T).pipe(w(be=>[[...K,...be],T+x,be.length<x]))),ge(),P(A),w(([K,,T])=>d(["commits",K],["allCommitsLoaded",T])))))}case S.currentBranch:return this.repositoriesApi.getCurrentBranch(e).pipe(P(A),w(m=>d(["currentBranch",m])));case S.currentBranchCommitId:return this.repositoriesApi.getCurrentBranchCommitId(e).pipe(P(A),w(m=>d(["currentBranchCommitId",m])));case S.currentBranchUpstreamBranch:return this.repositoriesApi.getCurrentBranchUpstreamBranch(e).pipe(P(A),w(m=>d(["currentBranchUpstreamBranch",m])));case S.headCommitId:return this.historyApi.getHeadCommitId(e).pipe(P(A),w(m=>d(["headCommitId",m])));case S.mergeHeads:return this.mergesApi.getMergeHeads(e).pipe(P(A),w(m=>d(["mergeHeads",m])));case S.merges:return this.mergesApi.getMerges(e).pipe(P(A),w(m=>d(["merges",m])));case S.name:return this.repositoriesApi.getRepositoryName(e).pipe(P(A),w(m=>d(["name",m])));case S.references:{let m=this.store.selectSnapshot(M.repositorySettings)[e];if(!m)return F([]);let j=m.visibleReferences;return this.repositoriesApi.getReferences(e).pipe(P(A),b(O=>{let K=new Set(O.map(Y=>Y.name)),T=j?.filter(Y=>K.has(Y))??null,de=!We(j,T);return this.store.dispatch(new ie(e,T&&T.length>0?T:null)).pipe(b(()=>de?this.store.dispatch(new z(e,[S.commits])).pipe(w(()=>O)):F(O)))}),w(O=>d(["references",O])))}case S.remotes:return this.remotesApi.getRemotes(e).pipe(P(A),w(m=>d(["remotes",m])));case S.stagedChanges:return this.repositoriesApi.getStagedChanges(e).pipe(P(A),w(m=>l?.area==="staged"&&!m.some(c)?d(["stagedChanges",m],["selectedFile",null]):d(["stagedChanges",m])));case S.stashes:return this.stashApi.get(e).pipe(P(A),w(m=>d(["stashes",m])));case S.submodules:return this.submodulesApi.getSubmoduleNames(e).pipe(P(A),w(m=>d(["submodules",m])),ye([]));case S.unstagedChanges:return this.repositoriesApi.getUnstagedChanges(e).pipe(P(A),w(m=>l?.area==="unstaged"&&!m.some(c)?d(["unstagedChanges",m],["selectedFile",null]):d(["unstagedChanges",m])));default:return F([])}});return ue(f.map(C=>C.pipe(ye([]))))}static{this.\u0275fac=function(e){return new(e||ae)(I(Ue),I(_e),I($),I(ee),I(Ke),I(Ye),I(Je),I(rt),I(Z),I(q),I($e),I(Ge),I(Xe))}}static{this.\u0275prov=J({token:ae,factory:ae.\u0275fac})}};return a([u(ne)],s.prototype,"initializeTransient",null),a([u(_)],s.prototype,"openTransientRepository",null),a([u(pe)],s.prototype,"closeTransientRepository",null),a([u(te)],s.prototype,"changeSelectedCommit",null),a([u(oe)],s.prototype,"changeSelectedMerge",null),a([u(dt)],s.prototype,"changeSelectedFile",null),a([u(we)],s.prototype,"workingDirectoryChanged",null),a([u(z)],s.prototype,"refreshRepository",null),a([u(Ae,{cancelUncompleted:!0})],s.prototype,"loadRepositoryCommits",null),a([u(se)],s.prototype,"scrollRepository",null),a([u(re)],s.prototype,"scrollRepositoryToCommit",null),a([u(yt)],s.prototype,"loadCommitEdit",null),a([u(Rt)],s.prototype,"performRepositoryAction",null),a([u(gt)],s.prototype,"undoLastAction",null),a([u(ft)],s.prototype,"redoLastAction",null),a([u(St)],s.prototype,"resetState",null),a([h()],s,"isInitialized",null),a([h()],s,"openRepositories",null),a([h()],s,"loadingRepositories",null),a([h([le])],s,"repositorySettings",null),s})();y=M=a([G({name:"repositoriesTransient",defaults:It})],y);var W,Pt={version:5,openRepositoryIds:[],recentlyClosed:[],repositoryBookmarks:[],repositorySettings:{},selectedRepositoryId:null},Ct=(()=>{let s=class ce{static{W=this}static{this.maxRecentlyClosed=10}static repositoryBookmarks(t){return t.repositoryBookmarks}static repositorySettings(t){return t.repositorySettings}static openRepositoryIds(t){return t.openRepositoryIds}static openRepositories(t,e){return t.openRepositoryIds.flatMap(o=>{let r=t.repositorySettings[o],n=e.openRepositories[o];return r&&n?i(i({},r),n):[]})}static openOrLoadingRepositories(t,e){return t.openRepositoryIds.flatMap(o=>{let r=t.repositorySettings[o],n=e.openRepositories[o];if(r&&n)return i(i({},r),n);let l=t.repositorySettings[o];return r&&l?i(i({},r),l):[]})}static recentRepositories(t){return t.recentlyClosed}static repositoryNames(t,e){return Object.fromEntries([...Object.entries(e.openRepositories).map(([o,r])=>[o,r.name]),...t.recentlyClosed.map(o=>[o.repositoryId,o.name])])}static selectedRepository(t,e){if(t.selectedRepositoryId===null)return null;let o=t.repositorySettings[t.selectedRepositoryId],r=e.openRepositories[t.selectedRepositoryId];return o&&r?i(i({},o),r):null}static selectedRemote(t){return t.selectedRepositoryId===null?null:t.repositorySettings[t.selectedRepositoryId]?.selectedRemote??null}static selectedRemotes(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.remotes??null}static remotesForRepository(t){return V([W,y],(e,o)=>{let r=o.openRepositories[t];return r?r.remotes:null})}static selectedRepositoryPath(t){return t.selectedRepositoryId===null?null:t.repositorySettings[t.selectedRepositoryId]?.path??null}static selectedCommitId(t){return t.selectedRepositoryId===null?null:t.repositorySettings[t.selectedRepositoryId]?.selectedCommitId??null}static selectedMergeId(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.selectedMergeId??null}static selectedFile(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.selectedFile??null}static selectedFileForArea(t){return V([W,y],(e,o)=>{if(e.selectedRepositoryId===null)return null;let r=o.openRepositories[e.selectedRepositoryId]?.selectedFile??null;return r?.area===t?r:null})}static selectedStagedChanges(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.stagedChanges??null}static selectedUnstagedChanges(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.unstagedChanges??null}static selectedMergeHeads(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.mergeHeads??null}static selectedRepositoryHeadCommitId(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.headCommitId??null}static selectedRepositoryCommits(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.commits??null}static selectedRepositoryCredentials(t,e){if(!t.selectedRepositoryId)return{};let o=t.repositorySettings[t.selectedRepositoryId]?.profiles.get(e.selectedProfileId)?.remotes;return o?Object.fromEntries(Object.entries(o).map(([r,{credentialId:n}])=>{let l=n===null?null:e.credentials.get(n)??null;return[r,l?p(i({},l),{credentialId:n}):null]})):{}}static selectedRepositoryLocalBranches(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.references.filter(o=>o.type==="local")??null}static selectedRepositoryRemoteBranches(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.references.filter(o=>o.type==="remote")??null}static selectedRepositoryTags(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.references.filter(o=>o.type==="tag")??null}static selectedRepositoryCurrentBranch(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.currentBranch??null}static selectedRepositoryCurrentBranchCommitId(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.currentBranchCommitId??null}static selectedRepositoryCurrentBranchUpstreamBranch(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.currentBranchUpstreamBranch??null}static selectedRepositorySubmodules(t,e){return t.selectedRepositoryId===null?[]:e.openRepositories[t.selectedRepositoryId]?.submodules??[]}static selectedRepositoryCommitMessage(t){return t.selectedRepositoryId===null?null:t.repositorySettings[t.selectedRepositoryId]?.commitMessage??null}static selectedRepositoryVisibleReferences(t){return t.selectedRepositoryId===null?null:t.repositorySettings[t.selectedRepositoryId]?.visibleReferences??null}static selectedRepositoryExpandedBranches(t){return t.selectedRepositoryId===null?new Set:t.repositorySettings[t.selectedRepositoryId]?.expandedBranches??new Set}static selectedRepositoryLoadingCommitEdit(t,e){return t.selectedRepositoryId===null?!1:e.openRepositories[t.selectedRepositoryId]?.loadingCommitEdit??!1}static selectedRepositoryPerformingAction(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.performingAction??null}static selectedRepositoryMostRecentAction(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.recentActions?.[0]??null}static selectedRepositoryMostRecentUndoneAction(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.recentUndoneActions?.[0]??null}static selectedRepositoryStashes(t,e){return t.selectedRepositoryId===null?null:e.openRepositories[t.selectedRepositoryId]?.stashes??null}addRepository(t,e){t.setState(o=>o.repositorySettings[e.repositoryPath]?o:p(i({},o),{repositorySettings:p(i({},o.repositorySettings),{[e.repositoryPath]:i({path:e.repositoryPath,selectedCommitId:"head",profiles:new Map,selectedRemote:"origin",remoteSettings:new Map,commitMessage:null,visibleReferences:null,expandedBranches:new Set},e.settings)})}))}deleteRepository(t,e){return t.dispatch(new Pe(e.repositoryPath)).pipe(v(()=>{let o=r=>{for(let n of r){if("children"in n){if(o(n.children))return!0;continue}if(n.repositoryId===e.repositoryPath)return!0}return!1};t.setState(r=>p(i({},r),{recentlyClosed:r.recentlyClosed.filter(n=>n.repositoryId!==e.repositoryPath),repositorySettings:o(r.repositoryBookmarks)?r.repositorySettings:D(r.repositorySettings,e.repositoryPath)}))}))}openRepository(t,e){let o=this.store.selectSnapshot(y.openRepositories);if(!o[e.repositoryPath])return t.dispatch(new Ce(e.repositoryPath)).pipe(b(()=>this.authService.accessLevel.pipe(Ee(1))),b(r=>r==="pro"||Object.keys(o).length<2?(t.setState(n=>p(i({},n),{openRepositoryIds:Ie([...n.openRepositoryIds,e.repositoryPath]),recentlyClosed:n.recentlyClosed.filter(l=>l.repositoryId!==e.repositoryPath)})),t.dispatch(new _(e.repositoryPath)).pipe(k(n=>this.repositoriesApi.getRepositoryName(e.repositoryPath).pipe(b(l=>(t.setState(c=>p(i({},c),{openRepositoryIds:c.openRepositoryIds.filter(d=>d!==e.repositoryPath),recentlyClosed:[{date:new Date,name:l,repositoryId:e.repositoryPath},...c.recentlyClosed],selectedRepositoryId:c.selectedRepositoryId===e.repositoryPath?null:c.selectedRepositoryId})),E(()=>n))))))):(this.telemetryService.reportLead("Tried to open more than two tabs."),E(()=>new B(new Me)))))}closeRepository(t,e){return this.repositoriesApi.getRepositoryName(e.repositoryPath).pipe(b(o=>(t.setState(r=>{let n=r.openRepositoryIds.findIndex(f=>f===e.repositoryPath);if(n===-1)return r;let l=r.openRepositoryIds.filter(f=>f!==e.repositoryPath),c=r.recentlyClosed.findIndex(f=>f.repositoryId===e.repositoryPath),d=c>=0?[...r.recentlyClosed.slice(0,c),...r.recentlyClosed.slice(c+1)]:r.recentlyClosed.slice(0,W.maxRecentlyClosed-1);return p(i({},r),{recentlyClosed:[{date:new Date,name:o,repositoryId:e.repositoryPath},...d],openRepositoryIds:l,selectedRepositoryId:r.selectedRepositoryId===e.repositoryPath?l.length>0?n<l.length?l[n]??null:l[l.length-1]??null:null:r.selectedRepositoryId})}),t.dispatch(new pe(e.repositoryPath)))))}updateRepositoryBookmarks(t,e){t.setState(o=>p(i({},o),{repositoryBookmarks:e.bookmarks}))}changeSelectedRemote(t,e){return this.remotesApi.getRemotes(e.repositoryPath).pipe(b(o=>e.remote&&o.every(r=>r.name!==e.remote)?E(()=>new B(new Ne(e.remote??"",o.map(r=>r.name)))):(t.setState(r=>p(i({},r),{repositorySettings:g(r.repositorySettings,e.repositoryPath,n=>p(i({},n),{selectedRemote:e.remote}))})),L)))}addOrUpdateProfileCredential(t,e){t.setState(o=>p(i({},o),{repositorySettings:g(o.repositorySettings,e.repositoryPath,r=>p(i({},r),{profiles:new Map([...r.profiles,[e.profileId,e.credentials]])}))}))}reorderOpenRepositories(t,e){t.setState(o=>{let r=this.store.selectSnapshot(y.openRepositories),n=this.store.selectSnapshot(y.loadingRepositories);if(Object.keys(r).length+Object.keys(n).length!==o.openRepositoryIds.length)throw new xe(Object.keys(r),Object.keys(n),o.openRepositoryIds);if(e.repositoryPaths.length!==Ie(e.repositoryPaths).length)throw new je(e.repositoryPaths);if(o.openRepositoryIds.some(l=>!e.repositoryPaths.includes(l))||e.repositoryPaths.some(l=>!o.openRepositoryIds.includes(l)))throw new Le(e.repositoryPaths,o.openRepositoryIds);return p(i({},o),{openRepositoryIds:e.repositoryPaths})})}changeSelectedRepository(t,e){t.setState(o=>p(i({},o),{selectedRepositoryId:e.repositoryPath&&o.openRepositoryIds.includes(e.repositoryPath)?e.repositoryPath:null}))}changeSelectedCommit(t,e){(t.getState().repositorySettings[e.repositoryPath]?.selectedCommitId??null)!==e.commitId&&t.setState(o=>p(i({},o),{repositorySettings:g(o.repositorySettings,e.repositoryPath,r=>p(i({},r),{selectedCommitId:e.commitId}))}))}changeSelectedMerge(t,e){t.setState(o=>p(i({},o),{repositorySettings:g(o.repositorySettings,e.repositoryPath,r=>p(i({},r),{selectedCommitId:e.mergeId?null:r.selectedCommitId}))}))}updateCommitMessage(t,e){t.setState(o=>p(i({},o),{repositorySettings:U(o.repositorySettings,(r,n)=>r===e.repositoryPath?p(i({},n),{commitMessage:e.message}):n)}))}changeVisibleReferences(t,e){t.setState(o=>p(i({},o),{repositorySettings:U(o.repositorySettings,(r,n)=>r===e.repositoryPath?p(i({},n),{visibleReferences:e.referenceNames}):n)}))}changeBranchesExpanded(t,e){t.setState(o=>p(i({},o),{repositorySettings:U(o.repositorySettings,(r,n)=>{if(r!==e.repositoryPath)return n;let l=new Set(n.expandedBranches);if(e.expanded)for(let c of e.branchNames)l.add(c);else for(let c of e.branchNames)l.delete(c);return p(i({},n),{expandedBranches:l})})}))}addOrUpdateProfile(t,e){let o=t.getState().selectedRepositoryId;!o||this.store.selectSnapshot(H.selectedProfileId)!==e.id||e.profile.allowedRepositories!=="all"&&!e.profile.allowedRepositories.includes(o)&&this.store.dispatch(new N(null))}setSelectedProfile(t,e){let o=t.getState().selectedRepositoryId;if(!o)return;let r=this.store.selectSnapshot(H.profiles).get(e.profileId);r&&r.allowedRepositories!=="all"&&!r.allowedRepositories.includes(o)&&this.store.dispatch(new N(null))}deleteProfile(t,e){t.setState(o=>p(i({},o),{repositorySettings:U(o.repositorySettings,(r,n)=>p(i({},n),{profiles:new Map([...n.profiles].filter(([l])=>l!==e.id))}))}))}deleteCredential(t,e){t.setState(o=>p(i({},o),{repositorySettings:U(o.repositorySettings,(r,n)=>p(i({},n),{profiles:new Map([...n.profiles].map(([l,c])=>[l,c&&{remotes:U(c.remotes,(d,f)=>f.credentialId===e.id?p(i({},f),{credentialId:null}):f)}]))}))}))}resetState(t,e){t.setState(X(Pt))}constructor(t,e,o,r,n,l){this.store=t,this.authService=e,this.avatarCacheService=o,this.remotesApi=r,this.repositoriesApi=n,this.telemetryService=l}ngxsOnInit(t){this.authService.init().then(()=>{let e=t.getState();t.dispatch(new ne(e.openRepositoryIds,e.selectedRepositoryId)).subscribe(()=>{this.setupAutoFetch(),this.avatarCacheService.loadFromIntegrations()})})}setupAutoFetch(){return this.store.select(H.autoFetchInterval).pipe(b(t=>t?Be(t):L),Te(this.store.select(W.openRepositories),this.store.select(H.selectedProfileId),this.store.select(H.credentials)),v(([,t,e,o])=>{for(let r of t)this.remotesApi.fetchAll(r.path,this.getRepositoryCredentials(r.profiles,e,o)).pipe(k(()=>L)).subscribe(()=>{this.store.dispatch(new z(r.path,[S.commits,S.references]))})})).subscribe()}getRepositoryCredentials(t,e,o){if(!e)return{};let r=t.get(e)?.remotes;return r?Object.fromEntries(Object.entries(r).map(([n,{credentialId:l}])=>[n,l===null?null:o.get(l)??null])):{}}static{this.\u0275fac=function(e){return new(e||ce)(I($),I(ot),I(ee),I(Z),I(q),I(st))}}static{this.\u0275prov=J({token:ce,factory:ce.\u0275fac})}};return a([u(Ce)],s.prototype,"addRepository",null),a([u(it)],s.prototype,"deleteRepository",null),a([u(nt)],s.prototype,"openRepository",null),a([u(Pe)],s.prototype,"closeRepository",null),a([u(pt)],s.prototype,"updateRepositoryBookmarks",null),a([u(lt)],s.prototype,"changeSelectedRemote",null),a([u(at)],s.prototype,"addOrUpdateProfileCredential",null),a([u(ct)],s.prototype,"reorderOpenRepositories",null),a([u(N)],s.prototype,"changeSelectedRepository",null),a([u(te)],s.prototype,"changeSelectedCommit",null),a([u(oe)],s.prototype,"changeSelectedMerge",null),a([u(ht)],s.prototype,"updateCommitMessage",null),a([u(ie)],s.prototype,"changeVisibleReferences",null),a([u(ut)],s.prototype,"changeBranchesExpanded",null),a([u(Ze)],s.prototype,"addOrUpdateProfile",null),a([u(et)],s.prototype,"setSelectedProfile",null),a([u(qe)],s.prototype,"deleteProfile",null),a([u(tt)],s.prototype,"deleteCredential",null),a([u(mt)],s.prototype,"resetState",null),a([h()],s,"repositoryBookmarks",null),a([h()],s,"repositorySettings",null),a([h()],s,"openRepositoryIds",null),a([h([s,y])],s,"openRepositories",null),a([h([s,y])],s,"openOrLoadingRepositories",null),a([h()],s,"recentRepositories",null),a([h([s,y])],s,"repositoryNames",null),a([h([s,y])],s,"selectedRepository",null),a([h()],s,"selectedRemote",null),a([h([s,y])],s,"selectedRemotes",null),a([h()],s,"selectedRepositoryPath",null),a([h()],s,"selectedCommitId",null),a([h([s,y])],s,"selectedMergeId",null),a([h([s,y])],s,"selectedFile",null),a([h([s,y])],s,"selectedStagedChanges",null),a([h([s,y])],s,"selectedUnstagedChanges",null),a([h([s,y])],s,"selectedMergeHeads",null),a([h([s,y])],s,"selectedRepositoryHeadCommitId",null),a([h([s,y])],s,"selectedRepositoryCommits",null),a([h([s,H])],s,"selectedRepositoryCredentials",null),a([h([s,y])],s,"selectedRepositoryLocalBranches",null),a([h([s,y])],s,"selectedRepositoryRemoteBranches",null),a([h([s,y])],s,"selectedRepositoryTags",null),a([h([s,y])],s,"selectedRepositoryCurrentBranch",null),a([h([s,y])],s,"selectedRepositoryCurrentBranchCommitId",null),a([h([s,y])],s,"selectedRepositoryCurrentBranchUpstreamBranch",null),a([h([s,y])],s,"selectedRepositorySubmodules",null),a([h()],s,"selectedRepositoryCommitMessage",null),a([h()],s,"selectedRepositoryVisibleReferences",null),a([h()],s,"selectedRepositoryExpandedBranches",null),a([h([s,y])],s,"selectedRepositoryLoadingCommitEdit",null),a([h([s,y])],s,"selectedRepositoryPerformingAction",null),a([h([s,y])],s,"selectedRepositoryMostRecentAction",null),a([h([s,y])],s,"selectedRepositoryMostRecentUndoneAction",null),a([h([s,y])],s,"selectedRepositoryStashes",null),s})();Ct=W=a([G({name:le,defaults:Pt})],Ct);export{Ce as a,it as b,nt as c,Pe as d,pt as e,lt as f,at as g,ct as h,N as i,te as j,dt as k,oe as l,S as m,z as n,Ae as o,se as p,re as q,ht as r,ie as s,ut as t,mt as u,yt as v,Rt as w,gt as x,ft as y,St as z,Mt as A,Ot as B,y as C,Ct as D};
